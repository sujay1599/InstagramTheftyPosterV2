### Updated README for Instagram Thefty Poster V3.1

# Instagram Thefty Poster V3.1

Instagram Thefty Poster V3.1 builds upon the features of V3, introducing several enhancements and new functionalities to improve the automation process of scraping, uploading, and managing Instagram reels.

## Features

- **All Features from V3**: Includes all functionalities from V3, such as scraping reels, uploading with customizable descriptions, adding to stories, interval-based tasks, and encrypted credentials.
- **Enhanced Randomized Actions**: More sophisticated random liking, commenting, and posting to simulate human behavior better.
- **Improved Dashboard**: Enhanced dashboard using the `rich` library for a more detailed and visually appealing display of activities.
- **Automated Scheduling**: More robust scheduling for scraping, uploading, and deletion tasks.
- **Detailed Logging**: Improved logging for better traceability and debugging.
- **Additional Configuration Options**: More settings for customization in `config.yaml`.
- **Random Intervals**: Added random intervals between actions to make the bot appear less robotic.

## Requirements

- Python 3.6+
- Required Python packages (specified in `requirements.txt`)

### Install Required Packages

You can install all the required packages using the following command:

```bash
pip install -r requirements.txt
```

## Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/sujay1599/InstagramTheftyPosterV3.git
   cd InstagramTheftyPosterV3
   ```

2. Install the required packages using `requirements.txt`:
   ```bash
   pip install -r requirements.txt
   ```

3. Run `start.py` to create the `config.yaml` file:
   ```bash
   python start.py
   ```
   Follow the prompts to enter your configuration details. This will generate a `config.yaml` file with the necessary settings, including encrypted Instagram credentials.

### Configuration

The `config.yaml` file will be generated by running `start.py`. It includes the following settings:

```yaml
instagram:
  username: ENCRYPTED_USERNAME
  password: ENCRYPTED_PASSWORD
key: ENCRYPTION_KEY
scraping:
  enabled: true
  profiles: profile1 profile2
  num_reels: 10
  scrape_interval_minutes: 60
uploading:
  enabled: true
  upload_interval_minutes: 30
  add_to_story: true
description:
  use_original: true
  custom_description: ""
hashtags:
  use_hashtags: true
  hashtags_list: "#example #hashtags"
credit:
  give_credit: true
leave_comment: true
comments:
  - "Nice reel!"
  - "Great post!"
deleting:
  delete_interval_minutes: 1440
```

- **Instagram Credentials**: Provide your Instagram username and password. These will be encrypted and stored securely.
- **Scraping Settings**:
  - `enabled`: Set to `true` to enable scraping.
  - `profiles`: Space-separated list of Instagram profiles to scrape reels from.
  - `num_reels`: Number of reels to scrape per profile.
  - `scrape_interval_minutes`: Interval in minutes between scraping sessions.
- **Uploading Settings**:
  - `enabled`: Set to `true` to enable uploading.
  - `upload_interval_minutes`: Interval in minutes between uploads.
  - `add_to_story`: Set to `true` to add reels to your Instagram story.
- **Description Settings**:
  - `use_original`: Set to `true` to use the original reel description. If `false`, you will be prompted to enter a custom description.
  - `custom_description`: The custom description to use if `use_original` is `false`.
- **Hashtags Settings**:
  - `use_hashtags`: Set to `true` to use hashtags in the reel descriptions.
  - `hashtags_list`: List of hashtags to include in the reel descriptions (if `use_hashtags` is `true`).
- **Credit Settings**:
  - `give_credit`: Set to `true` to give credit to the original poster in the reel descriptions.
- **Deleting Settings**:
  - `delete_interval_minutes`: Interval in minutes between deletions.
- **Comments**:
  - `leave_comment`: Set to `true` to leave comments on scraped videos.
  - `comments`: List of comments to leave if `leave_comment` is `true`.

## Usage

Run the script:
```bash
python main.py
```

### How It Works

1. **Scraping Reels**:
   - The script scrapes reels from specified Instagram profiles at random intervals.
   - After scraping, it randomly likes and comments on the reels to mimic human behavior.

2. **Uploading Reels**:
   - Scraped reels are uploaded to the user's Instagram account at random intervals.
   - Reels can be uploaded with the original or custom descriptions, and optionally added to the user's story.

3. **Dashboard**:
   - A detailed dashboard displays the scraping and uploading activities, including the status of recent actions, file counts, and random wait times.
   - Run the dashboard script to view detailed information:
     ```bash
     python dashboard.py
     ```
   - The terminal will populate the dashboard after each upload for convenience.

4. **Random Intervals**:
   - Random intervals are added between actions such as scraping, liking, commenting, and uploading to make the bot's activity appear more human-like.

### Troubleshooting

1. **Login Issues**:
   - If the script fails to login using the session file, it will attempt to login using the username and password. Ensure your credentials are correct.
   - Check for any changes in Instagram's login mechanisms that might require updating the `instagrapi` library.

2. **Missing Files**:
   - Ensure all required files (e.g., `status.json`, `config.yaml`) are in the correct directory.
   - If any file is deleted by mistake, re-run `start.py` to regenerate the `config.yaml` file.

3. **Scraping Errors**:
   - If scraping fails due to JSON decode errors or request exceptions, the script will retry with exponential backoff.
   - Ensure the target profiles are public and accessible.

4. **Uploading Errors**:
   - If uploading fails, the script logs the error and continues with the next reel. Check the logs for specific error messages.

5. **Random Wait Times**:
   - The script includes random wait times between actions. If these times seem too long or short, adjust the intervals in the configuration.

### Logging

The script maintains a log file (`upload_log.txt`) to keep track of uploaded reels, a status file (`status.json`) to track the last action times, and a random upload times file (`random-upload-times.json`) to log the random sleep times between uploads.

### Key Code Highlights

1. **Random Sleep Function**:
   ```python
   def random_sleep(min_time=5, max_time=30, action=""):
       sleep_time = random.uniform(min_time, max_time)
       wake_time = datetime.now() + timedelta(seconds=sleep_time)
       logging.info(f"Sleeping for {sleep_time:.2f} seconds before {action}. Will resume at {wake_time.strftime('%Y-%m-%d %H:%M:%S')}")
       sleep(sleep_time)
       return sleep_time
   ```

2. **Scraping Function**:
   ```python
      def scrape_reels(username, num_reels):
    global last_scraped_timestamp
    user_id = cl.user_id_from_username(username)
    all_downloaded_reels = []
    downloaded_reels = []
    backoff_time = 60  # Initial backoff time of 1 minute
    logging.info(f"Scraping reels from profile: {username}")
    while len(downloaded_reels) < num_reels:
        try:
            reels = cl.user_clips(user_id, amount=50)
        except requests.exceptions.JSONDecodeError as e:
            logging.error(f"JSONDecodeError: {e} - Retrying in {backoff_time} seconds")
            sleep(backoff_time)
            backoff_time *= 2  # Exponential backoff
            continue
        except requests.exceptions.RequestException as e:
            logging.error(f"RequestException: {e} - Retrying in {backoff_time} seconds")
            sleep(backoff_time)
            backoff_time *= 2  # Exponential backoff
            continue
        except Exception as e:
            logging.error(f"Error fetching reels: {e}")
            break

        if not reels:
            break

        for reel in reels:
            reel_timestamp = reel.taken_at.timestamp()
            reel_filename = f"{username}_{reel.pk}.mp4"
            expected_media_path = os.path.join('downloads', reel_filename)

            if reel.pk in uploaded_reels or os.path.exists(expected_media_path):
                continue

            if reel_timestamp <= last_scraped_timestamp:
                continue

            try:
                media_path = cl.clip_download(reel.pk, folder='downloads')
            except Exception as e:
                logging.error(f"Failed to download reel {reel.pk}: {e}")
                continue

            if os.path.exists(media_path):
                description_path = os.path.join('downloads', f'{reel.pk}.txt')
                with open(description_path, 'w', encoding='utf-8') as f:
                    f.write(reel.caption_text)
                logging.info(f"Scraped and saved reel: {reel.pk}")
                liked, commented = randomly_like_and_comment(reel, cl)
                if liked:
                    logging.info(f"Liked reel: {reel.pk}")
                if commented:
                    logging.info(f"Commented on reel: {reel.pk}")
                downloaded_reels.append(reel)
                all_downloaded_reels.append(f"{username}_{reel.pk}")
                if len(downloaded_reels) >= num_reels:
                    break

            random_sleep(2, 5, action="scraping next reel")  # Random delay between scraping reels

    if downloaded_reels:
        last_scraped_timestamp = max(reel.taken_at.timestamp() for reel in downloaded_reels)
        with open(last_scraped_file, 'w') as file:
            file.write(str(int(last_scraped_timestamp)))

        update_status(
            last_scrape_time=datetime.now().timestamp(),
            next_scrape_time=(datetime.now() + timedelta(minutes=SCRAPE_INTERVAL_MINUTES)).timestamp(),
            reels_scraped=all_downloaded_reels
        )

    logging.info(f"Finished scraping reels from profile: {username}")
    return downloaded_reels
   ```

3. **Uploading Function**:
   ```python
   def upload_reels_with_new_descriptions(unuploaded_reels):
       if not unuploaded_reels:
           logging.info("No new reels to upload.")
           return
       for reel_file in unuploaded_reels:
           reel_id = reel_file.split('_')[1].split('.')[0]
           profile_username = reel_file.split('_')[0]
           media_path = os.path.join('downloads', reel_file)
           description_path = os.path.join('downloads', f'{reel_id}.txt')
           if not os.path.exists(media_path) or f"{profile_username}_{reel_id}" in uploaded_reels:
               logging.info(f"Media file {media_path} not found or already uploaded. Skipping upload for reel: {reel_id}")
               continue

           # Read original description
           with open(description_path, 'r', encoding='utf-8') as f:
               original_description = f.read()

           # Build the final description
           new_description = build_description(original_description, profile_username)
           
           # Upload to Instagram feed
           try:
               logging.info(f"Uploading reel: {reel_id} with description: {new_description}")
               cl.clip_upload(media_path, new_description)
               logging.info(f"Uploaded reel: {reel_id} with description: {new_description}")
           except Exception as e:
               logging.error(f"Failed to upload reel {reel_id}: {e}")
               continue
           
           # Upload to Instagram story
           if ADD_TO_STORY:
               wait_time = random_sleep(30, 120, action="uploading to story")  # Random delay before adding to story
               log_random_waits('story upload', wait_time)
               logging.info(f"Uploading reel: {reel_id} to story with description: {new_description}")
               try:
                   cl.video_upload_to_story(media_path, new_description)
                   logging.info(f"Added reel: {reel_id} to story")
               except Exception as e:
                   logging.error(f"Failed to add reel {reel_id} to story: {e}")

           # Release video file resources using moviepy
           try:
               video = mp.VideoFileClip(media_path)
               video.reader.close()
               if video.audio:
                   video.audio.reader.close_proc()
           except Exception as e:
               logging.error(f"Failed to release video resources for {reel_id}: {e}")
           
           # Log the upload
           with open(log_filename, 'a') as log_file:
               log_file.write(f"{profile_username}_{reel_id}\n")
           
           # Update the set of uploaded reels
           uploaded_reels.add(f"{profile_username}_{reel_id}")
           
           update_status(
               last_upload_time=datetime.now().timestamp(),
               next_upload_time=(datetime.now() + timedelta(minutes=UPLOAD_INTERVAL_MINUTES)).timestamp()
           )
           
           if ADD_TO_STORY:
               update_status(
                   last_story_upload_time=datetime.now().timestamp(),
                   next_story_upload_time=(datetime.now() + timedelta(minutes=UPLOAD_INTERVAL_MINUTES)).timestamp()
               )

           # Show the dashboard after each upload
           show_dashboard()

           sleep_time = random_sleep(10, 60, action="next upload")  # Random sleep before next upload
           log_random_upload_times(sleep_time)
           log_random_waits('upload', sleep_time)

           next_upload_time = datetime.now() + timedelta(minutes=UPLOAD_INTERVAL_MINUTES)
           logging.info(f"Next upload at: {next_upload_time.strftime('%Y-%m-%d %H:%M:%S')}")
           logging.info(f"Waiting for {UPLOAD_INTERVAL_MINUTES} minutes before next upload.")
           sleep(UPLOAD_INTERVAL_MINUTES * 60)
   ```

## Dashboard

Run the dashboard script to view detailed information about scraping and uploading activities:

```bash
python dashboard.py
```

The terminal will populate the dashboard after each upload for convenience.

### Sample Dashboard

![Instagram Thefty Poster Dashboard](https://github.com/sujay1599/InstagramTheftyPosterV3/blob/main/Images/DashboardV3.jpg)

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

## Contributing

Contributions are welcome! Please open an issue or submit a pull request for any improvements or bug fixes.

## Disclaimer

This script is intended for educational and personal use only. Use it responsibly and ensure you comply with Instagram's terms of service and guidelines.

---

## Differences Between V3 and V3.1

### New Features in V3.1

1. **Enhanced Randomized Actions**:
   - Improved algorithms for randomized liking, commenting, and posting to better mimic human behavior.

2. **Improved Dashboard**:
   - A more detailed and visually appealing dashboard using the `rich` library to display scraping and uploading activities.

3. **Automated Scheduling**:
   - More robust scheduling mechanisms for tasks, ensuring smoother and more efficient operations.

4. **Detailed Logging**:
   - Enhanced logging capabilities for better traceability and easier debugging of issues.

5. **Additional Configuration Options**:
   - More settings available in the `config.yaml` file for greater customization of the tool’s behavior.

### Improvements from V3 to V3.1

- **Randomized Action Logic**: Improved logic to make actions such as liking, commenting, and posting more random and human-like.
- **User Interface**: A more comprehensive and user-friendly dashboard.
- **Scheduling and Automation**: Enhanced scheduling for more reliable automation of tasks.
- **Logging and Debugging**: More detailed logging for easier issue identification and resolution.
- **Configurable Options**: Greater flexibility with additional configurable options.

By incorporating these improvements and new features, V3.1 aims to provide a more efficient, reliable, and user-friendly experience for automating Instagram reel management tasks.
